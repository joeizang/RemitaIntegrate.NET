using RemitaIntegrate.NET.Abstractions;
using RemitaIntegrate.NET.Config;
using System;
using System.Security.Cryptography;
using System.Text;

namespace RemitaIntegrate.NET
{
    public class RemitaHashGenerator
    {
        /// <summary>
        /// Remita configuration that holds all the constants given by remita
        /// and allows for basic config values for other things like the apikey
        /// merchantid and servicetypeid to vary from client to client.
        /// </summary>
        public IntegrateConfig Config { get; private set; }

        /// <summary>
        /// Hasher required to perform all hashing required by remita.
        /// Use an IoC container to resolve to SHA512Managed instance
        /// </summary>
        public SHA512 HasherBase { get; private set; }


        public RemitaHashGenerator(IntegrateConfig config)
        {
            Config = config;
            HasherBase = new SHA512Managed();
        }

        /// <summary>
        /// Hashing required to create a new transaction. Complies to standards as stated by remita here
        /// https://www.remita.net/developers under Detailed Integration Specification
        /// </summary>
        /// <param name="post"></param>
        /// <returns></returns>
        public string HashRemitaRequest(RemitaPost post)
        {
            var hashString = post.MerchantId + post.ServiceTypeId + post.OrderId + post.Amount 
            + post.ResponseUrl + Config.ApiKey;
            
            Byte[] encryptedSha512 = ComputeHash(hashString);
            HasherBase.Clear();
            return BitConverter.ToString(encryptedSha512).Replace("-", "").ToLower();
        }


        /// <summary>
        /// Hashing required to query and get the status of any transaction.
        /// </summary>
        /// <param name="orderId">string that is generated by merchant code.</param>
        /// <returns></returns>
        public string HashRemitedValidate(string orderId)
        {
            var hashString = orderId + Config.ApiKey + Config.MerchantId;
            
            Byte[] encryptedSha512 = ComputeHash(hashString);
            HasherBase.Clear();
            return BitConverter.ToString(encryptedSha512).Replace("-", "").ToLower();
        }


        /// <summary>
        /// Hashing required for the retrying of any traction that had failed previously.
        /// </summary>
        /// <param name="rrr">string alpha numeric characters</param>
        /// <returns></returns>
        public string HashRemitedRePost(string rrr)
        {
            var hashString = Config.MerchantId + rrr + Config.ApiKey;
            
            Byte[] encryptedSha512 = ComputeHash(hashString);
            HasherBase.Clear();
            return BitConverter.ToString(encryptedSha512).Replace("-", "").ToLower();
        }

        /// <summary>
        /// Hashing for the querying of rrr of any remita based transaction
        /// </summary>
        /// <param name="rrr">string alpha numeric characters that uniquely identifies a remita based transaction.</param>
        /// <returns></returns>
        public string HashRrrQuery(string rrr)
        {
            var hashString = rrr + Config.ApiKey + Config.MerchantId;

            byte[] encryptedSha512 = ComputeHash(hashString);
            HasherBase.Clear();
            return BitConverter.ToString(encryptedSha512).Replace("-", "").ToLower();
        }

        private byte[] ComputeHash(string hashstring)
        {
            return HasherBase.ComputeHash(Encoding.UTF8.GetBytes(hashstring));
        }
    }
}
